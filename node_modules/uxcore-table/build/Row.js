'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Created by xy on 15/4/13.
 */
var Cell = require('./Cell');
var classnames = require('classnames');
var assign = require('object-assign');
var Const = require('uxcore-const');
var deepEqual = require('deep-equal');
var deepcopy = require('deepcopy');

var React = require('react');
var ReactDOM = require('react-dom');

var Row = function (_React$Component) {
    _inherits(Row, _React$Component);

    function Row(props) {
        _classCallCheck(this, Row);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _this.state = {
            expanded: _this.props.level < _this.props.levels ? true : false
        };
        return _this;
    }

    Row.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
        // 需要考虑的 prop 包括
        // columns, rowIndex(s), rowData, index(s), addRowClassName(f), rowSelection, subComp(f), actions
        // mode(s), renderModel(s), fixedColumn(s), levels(s)
        var me = this;
        var shouldUpdate = false;
        ['rowIndex', 'index', 'mode', 'renderModel', 'fixedColumn', 'levels', 'addRowClassName', 'subComp'].forEach(function (item) {
            if (me.props[item] !== nextProps[item]) {
                shouldUpdate = true;
            }
        });
        if (!shouldUpdate) {
            ['columns', 'rowData', 'rowSelection', 'actions'].forEach(function (item, index) {
                if (!deepEqual(me.props[item], nextProps[item])) {
                    shouldUpdate = true;
                }
            });
        };
        if (!shouldUpdate) {
            shouldUpdate = me.state.expanded !== nextState.expanded;
        }
        return shouldUpdate;
    };

    Row.prototype.handleClick = function handleClick(rowData) {
        var me = this;
    };

    Row.prototype.handleDoubleClick = function handleDoubleClick(rowData) {
        var table = this.props.root;
        if (table.props.doubleClickToEdit) {
            table.editRow(deepcopy(rowData));
        }
    };

    Row.prototype.showSubCompFunc = function showSubCompFunc() {
        var me = this;
        me.props.root.toggleSubComp(me.props.rowData);
    };

    Row.prototype.renderSubComp = function renderSubComp() {
        var props = this.props;

        if (props.renderModel == 'tree') {
            return false;
        } else {
            if (props.subComp) {
                if (props.rowData.showSubComp) {
                    var subComp = React.cloneElement(props.subComp, {
                        passedData: this.props.rowData,
                        parentHasCheckbox: !!this.props.rowSelection,
                        parentHasCheck: !!this.props.rowSelection /////
                    });
                    return React.createElement(
                        'div',
                        { className: 'kuma-uxtable-subrow', ref: 'subRow' },
                        subComp
                    );
                }
                return false;
            } else if (props.renderSubComp) {
                var subComp = props.renderSubComp(deepcopy(props.rowData));
                if (subComp && props.rowData.showSubComp) {
                    return React.createElement(
                        'div',
                        { className: 'kuma-uxtable-subrow', ref: 'subRow' },
                        subComp
                    );
                }
                return false;
            } else {
                return false;
            }
        }
    };

    Row.prototype.renderChild = function renderChild() {

        var props = this.props,
            me = this,
            children = [];

        if (props.renderModel !== 'tree') {
            return children;
        }
        if (props.rowData.datas) {
            props.rowData.datas.forEach(function (node) {
                var renderProps = assign({}, props, {
                    level: me.props.level + 1,
                    rowData: node,
                    rowIndex: node.jsxid,
                    key: node.jsxid,
                    showSubComp: false,
                    visible: me.state.expanded && me.props.visible
                });
                children.push(React.createElement(Row, renderProps));
            });

            var renderProps = {
                key: "treeRow" + this.props.rowData.jsxid,
                className: "kuma-uxtable-tree-row"
            };

            children = React.createElement(
                'ul',
                renderProps,
                children
            );
        }

        return children;
    };

    Row.prototype.renderExpendIcon = function renderExpendIcon(rowIndex) {

        var expandCollapseIcon = undefined,
            props = this.props,
            _expandIconClass = undefined;

        if (props.renderModel !== 'tree') {
            return false;
        }

        if (props.rowData.datas) {
            if (!this.state.expanded) {

                _expandIconClass = {
                    "kuma-icon": true,
                    "kuma-icon-tree-open-2": false,
                    "kuma-icon-tree-close-2": true
                };
                _expandIconClass["kuma-uxtable-expandIcon-" + props.fixedColumn + "-" + rowIndex] = true;

                expandCollapseIcon = React.createElement(
                    'span',
                    { className: 'kuma-uxtable-tree-icon', 'data-type': props.fixedColumn, 'data-index': rowIndex,
                        onClick: this.toggleExpanded.bind(this) },
                    React.createElement('i', { className: classnames(_expandIconClass) })
                );
            } else {

                _expandIconClass = {
                    "kuma-icon": true,
                    "kuma-icon-tree-open-2": true,
                    "kuma-icon-tree-close-2": false
                };
                _expandIconClass["kuma-uxtable-expandIcon-" + props.fixedColumn + "-" + rowIndex] = true;

                expandCollapseIcon = React.createElement(
                    'span',
                    { className: 'kuma-uxtable-tree-icon', 'data-type': props.fixedColumn, 'data-index': rowIndex,
                        onClick: this.toggleExpanded.bind(this) },
                    React.createElement('i', { className: classnames(_expandIconClass) })
                );
            }
        } else {
            expandCollapseIcon = React.createElement('span', { className: 'kuma-uxtable-emptyicon' });
        }
        return expandCollapseIcon;
    };

    Row.prototype.renderIndent = function renderIndent() {
        var indents = [];
        if (this.props.renderModel == 'tree') {
            for (var i = 0; i < this.props.level - 1; i++) {
                var renderProps = {
                    className: "indent",
                    key: 'indent' + i
                };
                indents.push(React.createElement('span', renderProps));
            }
        }

        return indents;
    };

    Row.prototype.toggleExpanded = function toggleExpanded(e) {
        this.setState({ expanded: !this.state.expanded });
        e.stopPropagation();
        var t = $(e.target);
        if (!t.hasClass('kuma-uxtable-tree-icon')) {
            t = t.parents('.kuma-uxtable-tree-icon');
        }
        if (t.data('type') == 'fixed') {
            $(".kuma-uxtable-expandIcon-scroll" + "-" + t.data('index')).trigger('click');
        } else if (t.data('type') == 'scroll') {
            $(".kuma-uxtable-expandIcon-fixed" + "-" + t.data('index')).trigger('click');
        }
    };

    Row.prototype.render = function render() {
        var _classnames;

        var props = this.props,
            _columns = [],
            _style = {},
            _data = props.data,
            me = this,
            otherCls = props.addRowClassName(_data[props.rowIndex]);

        if (!this.props.visible) {
            _style = {
                display: 'none'
            };
        }

        props.columns.forEach(function (column, index) {
            if ("group" in column) {
                _columns = _columns.concat(column.columns);
            } else {
                _columns.push(column);
            }
        });

        var firstVisableColumn = 0;

        return React.createElement(
            'li',
            { className: classnames((_classnames = {}, _classnames[this.props.jsxprefixCls] = true, _classnames[otherCls] = !!otherCls, _classnames)), style: _style,
                onClick: this.handleClick.bind(this, props.rowData),
                onDoubleClick: this.handleDoubleClick.bind(this, props.rowData) },
            _columns.map(function (item, index) {
                if (item.hidden) return;
                firstVisableColumn++;
                var renderProps = {
                    column: item,
                    root: props.root,
                    align: item.align,
                    rowData: props.rowData,
                    rowIndex: props.rowIndex,
                    index: props.index,
                    cellIndex: index,
                    hasSubComp: props.subComp ? true : props.renderSubComp ? props.renderSubComp(deepcopy(props.rowData)) : false,
                    data: _data,
                    changeSelected: me.props.changeSelected,
                    showSubCompCallback: me.showSubCompFunc.bind(me),
                    rowSelection: props.rowSelection,
                    actions: props.actions,
                    mode: props.mode,
                    handleDataChange: props.handleDataChange,
                    attachCellField: props.attachCellField,
                    detachCellField: props.detachCellField,
                    key: "cell" + index
                };

                if (firstVisableColumn == 1) {
                    return React.createElement(
                        Cell,
                        renderProps,
                        me.renderIndent(),
                        me.renderExpendIcon(props.rowIndex)
                    );
                }
                //if have vertical data structure, how to process it
                return React.createElement(Cell, renderProps);
            }),
            me.renderChild(),
            this.renderSubComp()
        );
    };

    return Row;
}(React.Component);

;

Row.propTypes = {
    jsxprefixCls: React.PropTypes.string,
    showSubComp: React.PropTypes.bool
};

Row.defaultProps = {
    jsxprefixCls: "kuma-uxtable-row",
    showSubComp: false
};

exports["default"] = Row;
module.exports = exports['default'];
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var classnames = require('classnames');
var assgin = require('object-assign');

var React = require('react');
var ReactDOM = require('react-dom');

var CellField = function (_React$Component) {
    _inherits(CellField, _React$Component);

    function CellField(props) {
        _classCallCheck(this, CellField);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _this.state = {
            pass: true
        };

        return _this;
    }

    CellField.prototype.componentDidMount = function componentDidMount() {
        var me = this;
        me.props.attachCellField(me.validate.bind(this), me.getName());
    };

    CellField.prototype.componentWillUnmount = function componentWillUnmount() {
        var me = this;
        me.props.detachCellField(me.getName());
    };

    CellField.prototype.handleDataChange = function handleDataChange(obj) {
        var me = this;
        var jsxid = obj.jsxid;
        var column = obj.column;
        var value = obj.value;
        var text = obj.text;

        me.validate(value, function (pass) {
            me.props.handleDataChange(assgin({}, obj, {
                pass: pass
            }));
        });
        // me.props.handleDataChange(assgin({}, obj, {
        //     pass: me.state.pass
        // }));
    };

    CellField.prototype.getName = function getName() {
        var me = this;
        return me.props.column.dataKey + "." + me.props.index;
    };

    CellField.prototype.validate = function validate(value, cb) {
        var me = this;
        value = value || me.props.value;
        var rowData = me.props.rowData;
        var rules = me.props.column.rules;

        var pass = true;
        var errMsg = "";
        if ((typeof rules === 'undefined' ? 'undefined' : _typeof(rules)) == "object" && !Array.isArray(rules)) {
            pass = !!rules.validator(value, rowData);
            errMsg = rules.errMsg;
        } else if (Array.isArray(rules)) {
            for (var i = 0; i < rules.length; i++) {
                pass = rules[i].validator(value, rowData);
                if (!pass) {
                    errMsg = rules[i].errMsg;
                    break;
                }
            }
        }
        !!cb && cb(pass);
        me.setState({
            pass: pass,
            errMsg: errMsg
        });
        return pass;
    };

    CellField.prototype.renderContent = function renderContent() {};

    CellField.prototype.addSpecificClass = function addSpecificClass() {
        return this.props.prefixCls;
    };

    CellField.prototype.render = function render() {
        var _classnames;

        var me = this;
        var specificCls = me.addSpecificClass();
        return React.createElement(
            'div',
            { className: classnames((_classnames = {
                    "hasError": !me.state.pass
                }, _classnames[specificCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)) },
            me.renderContent()
        );
    };

    return CellField;
}(React.Component);

CellField.displayName = "CellField";
CellField.propTypes = {
    prefixCls: React.PropTypes.string
};

CellField.defaultProps = {
    prefixCls: 'kuma-uxtable-cell-field'
};

module.exports = CellField;
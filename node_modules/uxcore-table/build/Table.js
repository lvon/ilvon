"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Table Component for uxcore
 * @author zhouquan.yezq
 *
 * Copyright 2014-2015, UXCore Team, Alinw.
 * All rights reserved.
 */

var Header = require("./Header");
var Tbody = require("./Tbody");
var ActionBar = require("./ActionBar");
var CellField = require('./Cell/CellField');
var Pagination = require("uxcore-pagination");
var Const = require('uxcore-const');
var assign = require('object-assign');
var deepcopy = require('deepcopy');
var deepEqual = require('deep-equal');
var classnames = require("classnames");

var React = require('react');
var ReactDOM = require('react-dom');

var Table = function (_React$Component) {
    _inherits(Table, _React$Component);

    function Table(props) {
        _classCallCheck(this, Table);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _this.uid = 0;
        _this.fields = {};
        _this.state = {
            data: _this.addValuesInData(deepcopy(_this.props.jsxdata)), // checkbox 内部交互
            columns: _this.processColumn(), // column 内部交互
            showMask: _this.props.showMask, // fetchData 时的内部状态改变
            pageSize: props.pageSize, // pagination 相关
            currentPage: props.currentPage, // pagination 相关
            activeColumn: null,
            searchTxt: "",
            passedData: null,
            params: null,
            selected: [],
            expanded: false
        };
        return _this;
    }

    Table.prototype.componentWillMount = function componentWillMount() {
        if (this.props.fetchDataOnMount) {
            this.fetchData();
        }
    };

    Table.prototype.componentDidMount = function componentDidMount() {
        var me = this;
        me.el = ReactDOM.findDOMNode(me);
        if (!!me.state.data && !!me.state.data.datas) {
            console.warn("Table: 'content.data' rather than 'content.datas' is recommended, the support for 'content.datas' will be end from ver. 1.3.0");
        }
        if (me.props.subComp) {
            console.warn("Table: subComp is deprecated, use renderSubComp instead.");
        }
    };

    Table.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var me = this;
        var newData = {};
        if (!!nextProps.jsxdata && !!me.props.jsxdata && !me._isEqual(nextProps.jsxdata, me.props.jsxdata)) {
            // Data has changed, so uid which is used to mark the data should be reset.
            me.uid = 0;
            newData['data'] = me.addValuesInData(deepcopy(nextProps.jsxdata));
            me.data = deepcopy(newData['data']);
        }
        if (nextProps.pageSize != me.props.pageSize) {
            newData['pageSize'] = nextProps.pageSize;
        }
        if (nextProps.currentPage != me.props.currentPage) {
            newData['currentPage'] = nextProps.currentPage;
        }
        if (!!nextProps.jsxcolumns && !!me.props.jsxcolumns && !me._isEqual(nextProps.jsxcolumns, me.props.jsxcolumns)) {
            newData['columns'] = me.processColumn(nextProps);
        }
        me.setState(newData);
    };

    Table.prototype.componentWillUnmount = function componentWillUnmount() {
        var me = this;
    };

    /**
     * For inline edit
     * receive changes from cell field and change state.data
     * inform users of the change with dataKey & pass
     */

    Table.prototype.handleDataChange = function handleDataChange(obj) {
        var me = this;
        var jsxid = obj.jsxid;
        var column = obj.column;
        var value = obj.value;
        var text = obj.text;
        var pass = obj.pass;

        var dataKey = column.dataKey;
        var editKey = column.editKey || dataKey;
        var data = deepcopy(me.state.data);
        var changedData = {};
        for (var i = 0; i < data.data.length; i++) {
            if (data.data[i].jsxid == jsxid) {
                data.data[i][dataKey] = text;
                data.data[i][editKey] = value;
                changedData = data.data[i];
            }
        }

        me.setState({
            data: data
        }, function () {
            me.props.onChange({
                data: me.state.data,
                editKey: editKey,
                dataKey: dataKey,
                changedData: changedData,
                pass: pass
            });
        });
    };

    /**
     * register CellField to Table for the global validation
     * @param field {element} the cell field to be registered
     */

    Table.prototype.attachCellField = function attachCellField(validate, name) {
        var me = this;
        if (!name) {
            console.error("Table: name can not be empty, check the dataKey of the column config");
        } else {
            me.fields[name] = validate;
        }
    };

    /**
     * cancel the CellField when it is unmounted.
     * @param field {element} the cell field to be canceled.
     */

    Table.prototype.detachCellField = function detachCellField(name) {
        delete this.fields[name];
    };

    /**
     * simple method to compare two datas, 
     * only support the data which JSON can parse.
     */

    Table.prototype._isEqual = function _isEqual(a, b) {
        return deepEqual(a, b);
    };

    /**
     * get Query Object by combining data from searchBar, column order, pagination
     * and fetchParams.
     * @param from {string} used in props.beforeFetch
     */

    Table.prototype.getQueryObj = function getQueryObj(from) {

        var me = this,
            queryObj = {};
        if (me.props.passedData) {
            var queryKeys = me.props.queryKeys;
            if (!queryKeys) {
                queryObj = me.props.passedData;
            } else {
                queryKeys.forEach(function (key) {
                    if (me.props.passedData[key] !== undefined) {
                        queryObj[key] = me.props.passedData[key];
                    }
                });
            }
        }

        // pagination
        queryObj = assign({}, queryObj, {
            pageSize: me.state.pageSize,
            currentPage: me.state.currentPage
        });

        // column order
        var activeColumn = me.state.activeColumn;
        if (!!activeColumn) {
            queryObj = assign({}, queryObj, {
                orderColumn: activeColumn.dataKey,
                orderType: activeColumn.orderType
            });
        }

        // search query
        var searchTxt = me.state.searchTxt;
        if (!!searchTxt) {
            queryObj = assign({}, queryObj, {
                searchTxt: searchTxt
            });
        }

        // fetchParams has the top priority
        if (!!me.props.fetchParams) {
            queryObj = assign({}, queryObj, me.props.fetchParams);
        }

        return me.props.beforeFetch(queryObj, from);
    };

    /**
     * fetch Data via Ajax
     * @param from {string} tell fetchData where it is invoked, the param will be 
     * passed to props.beforeFetch in order to help the user.
     */

    Table.prototype.fetchData = function fetchData(from) {

        var me = this;
        // reset uid cause table data has changed
        me.uid = 0;

        // fetchUrl has the top priority.
        if (!!me.props.fetchUrl) {
            if (me.ajax) {
                me.ajax.abort();
            }
            if (!me.state.showMask) {
                me.setState({
                    showMask: true
                });
            }
            var ajaxOptions = {
                url: me.props.fetchUrl,
                data: me.getQueryObj(from),
                cache: false,
                dataType: "json",
                success: function success(result) {
                    if (result.success === true || result.hasError === false) {
                        var _data = result.content;
                        var processedData = me.addValuesInData(me.props.processData(deepcopy(_data)));
                        var updateObj = {
                            data: processedData,
                            showMask: false
                        };
                        if (processedData.currentPage !== undefined) {
                            updateObj.currentPage = processedData.currentPage;
                        }
                        me.data = deepcopy(processedData);
                        me.setState(updateObj);
                    } else {
                        me.props.onFetchError(result);
                    }
                }
            };

            if (/\.jsonp/.test(me.props.fetchUrl)) {
                ajaxOptions.dataType = "jsonp";
            }

            me.ajax = $.ajax(ajaxOptions);
        } else if (!!me.props.passedData) {

            if (!me.props.queryKeys) {
                var data = me.addValuesInData(me.props.processData(deepcopy(me.props.passedData)));
                me.setState({
                    data: data
                });
                me.data = deepcopy(data);
            } else {
                (function () {
                    var data = {};
                    me.props.queryKeys.forEach(function (key, index) {
                        if (me.props.passedData[key] !== undefined) {
                            data[key] = me.props.passedData[key];
                        }
                    });
                    var processedData = me.addValuesInData(me.props.processData(deepcopy(data)));
                    me.setState({
                        data: processedData
                    });
                    me.data = deepcopy(processedData);
                })();
            }
        } else if (!!this.props.jsxdata) {
            var data = this.addValuesInData(deepcopy(this.props.jsxdata));
            me.setState({
                data: data
            });
            me.data = deepcopy(data);
        } else {
            //default will create one row
            var data = {
                data: [{
                    jsxid: me.uid++,
                    __mode__: Const.MODE.EDIT
                }],
                "currentPage": 1,
                "totalCount": 0
            };
            me.data = deepcopy(data);
            me.setState({
                "data": deepcopy(data)
            });
        }
    };

    Table.prototype.processColumn = function processColumn(props) {

        props = props || this.props;

        var me = this,
            columns = deepcopy(props.jsxcolumns),
            hasCheckboxColumn = false;

        columns.forEach(function (item, i) {
            // only one rowSelector can be rendered in Table.
            if (item.type == 'checkbox' || item.type == 'radioSelector' || item.type == 'checkboxSelector') {
                if (item.type == 'checkbox') {
                    console.warn("rowSelector using 'type: checkbox' is deprecated, use 'type: checkboxSelector' instead.");
                }
                hasCheckboxColumn = true;
                me.checkboxColumn = item;
                me.checkboxColumnKey = item.dataKey;
                item.width = item.width || 46;
                item.align = item.align || 'right';
            }
        });

        // filter the column which has a dataKey 'jsxchecked' & 'jsxtreeIcon'

        columns = columns.filter(function (item) {
            return item.dataKey !== 'jsxchecked' && item.dataKey !== 'jsxtreeIcon';
        });

        // if hidden is not set, then it's false
        columns = columns.map(function (item, index) {
            item.hidden = !!item.hidden;
            return item;
        });

        if (!!props.rowSelection & !hasCheckboxColumn) {
            me.checkboxColumn = { dataKey: 'jsxchecked', width: 46, type: props.rowSelector, align: 'right' };
            me.checkboxColumnKey = 'jsxchecked';

            columns = [me.checkboxColumn].concat(columns);
        }

        // no rowSelection but has parentHasCheckbox, render placeholder
        else if (!!props.parentHasCheckbox) {
                columns = [{ dataKey: 'jsxwhite', width: 46, type: 'empty' }].concat(columns);
            }

            // no rowSelection but has parentHasCheck, render placeholder
            else if (!!props.parentHasCheck) {
                    columns = [{ dataKey: 'jsxwhite', width: 46, type: 'empty' }].concat(columns);
                }

        if ((!!props.subComp || !!props.renderSubComp) && props.renderModel !== 'tree') {
            columns = [{ dataKey: 'jsxtreeIcon', width: 34, type: 'treeIcon' }].concat(columns);
        }
        // no subComp but has passedData, means sub mode, parent should has tree icon,
        // render tree icon placeholder
        else if (!!props.passedData) {
                columns = [{ dataKey: 'jsxwhite', width: 34, type: 'empty' }].concat(columns);
            }

        return columns;
    };

    Table.prototype.handleColumnPickerChange = function handleColumnPickerChange(checkedKeys) {
        var _columns = deepcopy(this.state.columns);
        var notRenderColumns = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];

        _columns.forEach(function (item, index) {
            if ('group' in item) {
                item.columns.forEach(function (ele, idx) {
                    if (checkedKeys.indexOf(ele.dataKey) !== -1) {
                        ele.hidden = false;
                    } else {
                        ele.hidden = true;
                    }
                });
            } else {
                if (checkedKeys.indexOf(item.dataKey) !== -1 || notRenderColumns.indexOf(item.dataKey) !== -1) {
                    item.hidden = false;
                } else {
                    item.hidden = true;
                }
            }
        });
        this.setState({
            columns: _columns
        });
    };

    /**
     * change SelectedRows data via checkbox, this function will pass to the Cell
     * @param checked {boolean} the checkbox status
     * @param rowIndex {number} the row Index
     * @param fromMount {boolean} onSelect is called from cell Mount is not expected.
     */

    Table.prototype.changeSelected = function changeSelected(checked, rowIndex, fromMount) {

        var me = this;
        var _content = deepcopy(this.state.data);
        var _data = _content.datas || _content.data;

        me.checkboxColumn.type == 'radioSelector' ? _data.map(function (item, index) {
            if (item.jsxid == rowIndex) {
                item[me.checkboxColumnKey] = checked;
                return item;
            } else if (item[me.checkboxColumnKey]) {
                item[me.checkboxColumnKey] = false;
                return item;
            }
        }) : _data.map(function (item, index) {
            if (item.jsxid == rowIndex) {
                item[me.checkboxColumnKey] = checked;
                return item;
            }
        });

        me.setState({
            data: _content
        }, function () {
            if (!fromMount) {
                var data = me.state.data.datas || me.state.data.data;
                var selectedRows = data.filter(function (item, index) {
                    return item[me.checkboxColumnKey] == true;
                });
                !!me.props.rowSelection && !!me.props.rowSelection.onSelect && me.props.rowSelection.onSelect(checked, data[rowIndex], selectedRows);
            }
        });
    };

    Table.prototype.selectAll = function selectAll(checked) {

        var me = this;
        var _content = deepcopy(me.state.data);
        var _data = _content.datas || _content.data;
        var rowSelection = me.props.rowSelection;

        var selectedRows = [];
        _data = _data.forEach(function (item, index) {
            var column = me.checkboxColumn;
            var key = me.checkboxColumnKey;
            if (!('isDisable' in column) || !column.isDisable(item)) {
                item[key] = checked;
                selectedRows.push(item);
            }
        });

        if (!!rowSelection && !!rowSelection.onSelectAll) {
            rowSelection.onSelectAll.apply(null, [checked, checked ? selectedRows : []]);
        }
        me.setState({
            data: _content
        });
    };

    Table.prototype.onPageChange = function onPageChange(current) {
        var me = this;
        me.setState({
            currentPage: current
        }, function () {
            me.fetchData("pagination");
        });
    };

    Table.prototype.handleShowSizeChange = function handleShowSizeChange(current, pageSize) {
        var me = this;
        me.setState({
            currentPage: current,
            pageSize: pageSize
        }, function () {
            me.fetchData("pagination");
        });
    };

    Table.prototype.renderPager = function renderPager() {
        var me = this;
        var _me$state = me.state;
        var data = _me$state.data;
        var currentPage = _me$state.currentPage;
        var pageSize = _me$state.pageSize;
        var _me$props = me.props;
        var showPagerTotal = _me$props.showPagerTotal;
        var showPager = _me$props.showPager;
        var locale = _me$props.locale;


        if (showPager && data && data.totalCount) {
            return React.createElement(
                "div",
                { className: "kuma-uxtable-page" },
                React.createElement(Pagination, { className: "mini",
                    locale: locale,
                    showSizeChanger: true,
                    showTotal: showPagerTotal,
                    total: data.totalCount,
                    onShowSizeChange: me.handleShowSizeChange.bind(me),
                    onChange: me.onPageChange.bind(me),
                    current: currentPage,
                    pageSize: pageSize })
            );
        }
    };

    Table.prototype.handleOrderColumnCB = function handleOrderColumnCB(type, column) {
        var me = this;
        me.setState({
            activeColumn: column
        }, function () {
            me.fetchData("order");
        });
    };

    Table.prototype.handleActionBarSearch = function handleActionBarSearch(value) {
        var me = this;
        this.setState({
            searchTxt: value
        }, function () {
            me.fetchData("search");
        });
    };

    Table.prototype.getData = function getData(validate) {
        var me = this;
        var pass = true;
        if (validate !== false) {
            for (name in me.fields) {
                var fieldPass = me.fields[name]();

                // if one field fails to pass, the table fails to pass
                if (pass) {
                    pass = fieldPass;
                }
            }
        }
        if (me.props.getSavedData) {
            // 滤除可能为空的元素
            var data = deepcopy(me.data);
            data.data = data.data.filter(function (item) {
                return item != undefined;
            });
            return { data: data, pass: pass };
        } else {
            return { data: me.state.data, pass: pass };
        }
    };

    Table.prototype.hasFixColumn = function hasFixColumn() {
        var props = this.props;
        var _columns = props.jsxcolumns.filter(function (item) {
            if (item.fixed) {
                return true;
            }
        });
        if (_columns.length > 0) {
            return true;
        }
        return false;
    };

    Table.prototype.renderHeader = function renderHeader(renderHeaderProps) {

        if (!this.props.showHeader) {
            return;
        }

        if (this.hasFixColumn()) {
            return React.createElement(
                "div",
                { className: "kuma-uxtable-header-wrapper" },
                React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: "fixed", key: "grid-header-fixed" })),
                React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: "scroll", key: "grid-header-scroll" }))
            );
        } else {
            return React.createElement(
                "div",
                { className: "kuma-uxtable-header-wrapper" },
                React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: "no" }))
            );
        }
    };

    Table.prototype.renderTbody = function renderTbody(renderBodyProps, bodyHeight) {

        if (this.hasFixColumn()) {
            var subComp = renderBodyProps.subComp;

            var fixedBodyProps = _objectWithoutProperties(renderBodyProps, ["subComp"]);

            return React.createElement(
                "div",
                { className: "kuma-uxtable-body-wrapper", style: {
                        height: bodyHeight
                    } },
                React.createElement(Tbody, _extends({}, fixedBodyProps, { fixedColumn: "fixed", key: "grid-body-fixed" })),
                React.createElement(Tbody, _extends({}, renderBodyProps, { fixedColumn: "scroll", key: "grid-body-scroll" }))
            );
        } else {
            return React.createElement(
                "div",
                { className: "kuma-uxtable-body-wrapper", style: {
                        height: bodyHeight
                    } },
                React.createElement(Tbody, _extends({}, renderBodyProps, { fixedColumn: "no" }))
            );
        }
    };

    Table.prototype.render = function render() {
        var _classnames;

        var props = this.props;
        var bodyHeight = undefined;
        // if table is in sub mode, people always want to align the parent
        // and the sub table, so width should not be cared.
        var headerHeight = props.headerHeight;


        var _style = {
            width: !!props.passedData ? "auto" : props.width,
            height: props.height
        };
        var actionBarHeight = props.actionBar ? props.actionBarHeight : 0;
        var pagerHeight = props.showPager && this.state.data && this.state.data.totalCount ? 50 : 0;

        // decide whether the table has column groups
        var hasGroup = false;
        for (var i = 0; i < this.state.columns.length; i++) {
            if ('group' in this.state.columns[i]) {
                hasGroup = true;
                break;
            }
        }

        headerHeight = headerHeight || (hasGroup ? 80 : 40);

        if (props.height == 'auto') {
            bodyHeight = 'auto';
        } else {
            bodyHeight = props.height == "100%" ? props.height : props.height - headerHeight - actionBarHeight - pagerHeight;
        }
        var renderBodyProps = {
            columns: this.state.columns,
            data: this.state.data ? this.state.data.datas || this.state.data.data : [],
            onModifyRow: props.onModifyRow ? props.onModifyRow : function () {},
            rowSelection: props.rowSelection,
            addRowClassName: props.addRowClassName,
            subComp: props.subComp,
            renderSubComp: props.renderSubComp,
            mask: this.state.showMask,
            changeSelected: this.changeSelected.bind(this),
            rowHeight: this.props.rowHeight,
            height: bodyHeight,
            width: props.width,
            root: this,
            mode: props.mode,
            renderModel: props.renderModel,
            levels: props.levels,
            handleDataChange: this.handleDataChange.bind(this),
            attachCellField: this.attachCellField.bind(this),
            detachCellField: this.detachCellField.bind(this),
            key: 'grid-body'
        },
            renderHeaderProps = {
            columns: this.state.columns,
            activeColumn: this.state.activeColumn,
            checkAll: this.selectAll.bind(this),
            columnPicker: props.showColumnPicker,
            showHeaderBorder: props.showHeaderBorder,
            handleColumnPickerChange: this.handleColumnPickerChange.bind(this),
            headerHeight: props.headerHeight,
            width: props.width,
            mode: props.mode,
            orderColumnCB: this.handleOrderColumnCB.bind(this),
            key: 'grid-header'

        };

        var actionBar = undefined;

        if (props.actionBar || props.showSearch) {
            var renderActionProps = {
                onSearch: this.handleActionBarSearch.bind(this),
                actionBarConfig: this.props.actionBar,
                showSearch: this.props.showSearch,
                searchBarPlaceholder: this.props.searchBarPlaceholder,
                key: 'grid-actionbar'
            };
            actionBar = React.createElement(ActionBar, renderActionProps);
        }

        return React.createElement(
            "div",
            { className: classnames((_classnames = {}, _classnames[props.jsxprefixCls] = true, _classnames["kuma-subgrid-mode"] = !!props.passedData, _classnames)), style: _style },
            actionBar,
            React.createElement(
                "div",
                { className: "kuma-uxtable-content", style: {
                        width: !!props.passedData ? "auto" : props.width
                    } },
                this.renderHeader(renderHeaderProps),
                this.renderTbody(renderBodyProps, bodyHeight)
            ),
            this.renderPager()
        );
    };

    ///////////////////////// Util Method /////////////////////////

    /**
     * add some specific value for each row data which will be used in manipulating data & rendering.
     * used in record API.
     */

    Table.prototype.addJSXIdsForRecord = function addJSXIdsForRecord(objAux) {
        var me = this;
        if (objAux instanceof Array) {
            objAux = objAux.map(function (item) {
                if (item.jsxid == undefined || item.jsxid == null) {
                    item.jsxid = me.uid++;
                }
                if (!item.__mode__) {
                    item.__mode__ = Const.MODE.EDIT;
                }
                return item;
            });
        } else {
            objAux.jsxid = me.uid++;
        }
        return objAux;
    };

    /**
     * add some specific value for each row data which will be used in manipulating data & rendering.
     * used in method fetchData
     */

    Table.prototype.addValuesInData = function addValuesInData(objAux) {
        if (!objAux || !objAux.datas && !objAux.data) return;
        var me = this;
        var data = objAux.datas || objAux.data;
        data.forEach(function (node) {
            node.jsxid = me.uid++;
            node.__mode__ = node.__mode__ || Const.MODE.VIEW;
            me.addValuesInData(node);
        });
        return objAux;
    };

    /**
     * merge data
     */

    Table.prototype.mergeData = function mergeData(data, obj) {
        var newData = deepcopy(data);

        // code compatible
        if (!!newData.datas) {
            newData.datas = newData.datas.concat(obj);
        } else if (!!newData.data) {
            newData.data = newData.data.concat(obj);
        }
        newData.totalCount++;
        return newData;
    };

    /**
     * insert some data into this.state.data
     * @param objAux {Array or Object} datum or data need to be inserted
     */

    Table.prototype.insertRecords = function insertRecords(objAux) {
        if ((typeof objAux === "undefined" ? "undefined" : _typeof(objAux)) !== "object") return;
        var me = this;
        if (!(objAux instanceof Array)) {
            objAux = [objAux];
        }

        objAux = this.addJSXIdsForRecord(objAux);

        // me.data = me.mergeData(me.data, objAux);
        this.setState({
            data: me.mergeData(me.state.data, objAux)
        });
    };

    /**
     * @param {objAux} {a:'b',c:'d',jsxid:''}
     */


    Table.prototype.updateRecord = function updateRecord(objAux, cb) {
        var _data = this.state.data;

        if (!_data) {
            return;
        }

        if (_data.data || _data.datas) {
            var data = _data.data || _data.datas;

            data = data.map(function (item) {
                if (item.jsxid == objAux.jsxid) {
                    return objAux;
                } else {
                    return item;
                }
            });
            if (!!_data.data) {
                _data.data = data;
            } else if (!!_data.datas) {
                _data.datas = data;
            }
        }
        this.setState({
            data: _data
        }, function () {
            !!cb && cb();
        });
    };

    Table.prototype.syncRecord = function syncRecord(objAux) {
        var me = this;
        var _data = me.data.data || me.data.datas;

        me.updateRecord(objAux, function () {
            var _stateData = me.state.data.data || me.state.data.datas;
            // _data.forEach((item, index) => {
            //     if (item.jsxid == objAux.jsxid) {
            //         _data[index] = _stateData.filter((ele) => {
            //             return ele.jsxid == objAux.jsxid
            //         })[0];
            //     }
            // });
            _stateData.forEach(function (item, index) {
                if (item.jsxid == objAux.jsxid) {
                    _data[index] = item;
                }
            });
        });
    };

    Table.prototype.removeRecords = function removeRecords(objAux) {

        //at least one record
        var me = this;
        var content = this.state.data;
        var data = content.data || content.datas;

        // deepcopy protect
        var _content = deepcopy(content),
            _data = _content.data || _content.datas;

        if (Object.prototype.toString.call(objAux) !== "[object Array]") {
            objAux = [objAux];
        }

        objAux.map(function (item) {
            _data.forEach(function (element, index, array) {
                if (element.jsxid == item.jsxid) {
                    _data.splice(index, 1);
                }
            });
        });

        me.data = _content;

        this.setState({
            data: _content
        });
    };

    //////////////////////// CURD for gird ////////////////

    Table.prototype.addEmptyRow = function addEmptyRow() {
        this.insertRecords({});
    };

    Table.prototype.addRow = function addRow(rowData) {
        this.insertRecords(rowData);
    };

    Table.prototype.resetRow = function resetRow(rowData) {
        var me = this;
        var updateData = {};
        var _data = me.data.datas || me.data.data;
        for (var i = 0; i < _data.length; i++) {
            if (_data[i].jsxid == rowData.jsxid) {
                updateData = deepcopy(_data[i]);
                break;
            }
        }
        updateData['__mode__'] = Const.MODE.EDIT;
        this.updateRecord(updateData);
    };

    Table.prototype.delRow = function delRow(rowData) {
        this.removeRecords(rowData);
    };

    Table.prototype.editRow = function editRow(rowData) {
        rowData.__mode__ = Const.MODE.EDIT;
        this.updateRecord(rowData);
    };

    Table.prototype.viewRow = function viewRow(rowData) {
        rowData.__mode__ = Const.MODE.VIEW;
        this.updateRecord(rowData);
    };

    Table.prototype.saveRow = function saveRow(rowData) {
        rowData.__mode__ = Const.MODE.VIEW;
        rowData.__edited__ = true;
        this.syncRecord(rowData);
    };

    Table.prototype.saveAllRow = function saveAllRow() {
        var me = this;
        var data = deepcopy(me.state.data.data || me.state.data.datas);
        data.forEach(function (item) {
            me.saveRow(item);
        });
    };

    Table.prototype.editAllRow = function editAllRow() {
        var me = this;
        var data = deepcopy(me.data.data || me.data.datas);
        data.forEach(function (item) {
            me.editRow(item);
        });
    };

    Table.prototype.toggleSubComp = function toggleSubComp(rowData) {
        var _content = deepcopy(this.state.data);
        var _data = _content.data || _content.datas;

        if (_data) {
            _data = _data.map(function (item) {
                if (item.jsxid == rowData.jsxid) {
                    item.showSubComp = !item.showSubComp;
                    return item;
                } else {
                    return item;
                }
            });
        }
        this.setState({
            data: _content
        });
    };

    return Table;
}(React.Component);

;

Table.defaultProps = {
    jsxprefixCls: "kuma-uxtable",
    locale: "zh-cn",
    showHeader: true,
    width: "auto",
    height: "auto",
    mode: Const.MODE.EDIT,
    renderModel: '',
    levels: 1,
    actionBarHeight: 40,
    fetchDataOnMount: true,
    doubleClickToEdit: true,
    rowSelector: 'checkboxSelector',
    showPager: true,
    showColumnPicker: true,
    showHeaderBorder: false,
    showPagerTotal: false,
    showMask: false,
    showSearch: false,
    getSavedData: true,
    pageSize: 10,
    rowHeight: 76,
    fetchParams: {},
    currentPage: 1,
    queryKeys: [],
    emptyText: "暂无数据",
    searchBarPlaceholder: "搜索表格内容",
    processData: function processData(data) {
        return data;
    },
    beforeFetch: function beforeFetch(obj) {
        return obj;
    },
    onFetchError: function onFetchError() {},
    addRowClassName: function addRowClassName() {},
    onChange: function onChange() {}
};

// http://facebook.github.io/react/docs/reusable-components.html
Table.propTypes = {
    locale: React.PropTypes.string,
    jsxcolumns: React.PropTypes.arrayOf(React.PropTypes.object),
    width: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
    height: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
    headerHeight: React.PropTypes.number,
    pageSize: React.PropTypes.number,
    queryKeys: React.PropTypes.array,
    fetchDataOnMount: React.PropTypes.bool,
    doubleClickToEdit: React.PropTypes.bool,
    showColumnPicker: React.PropTypes.bool,
    showPager: React.PropTypes.bool,
    showPagerTotal: React.PropTypes.bool,
    showHeader: React.PropTypes.bool,
    showHeaderBorder: React.PropTypes.bool,
    showMask: React.PropTypes.bool,
    showSearch: React.PropTypes.bool,
    searchBarPlaceholder: React.PropTypes.string,
    subComp: React.PropTypes.element,
    emptyText: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.element]),
    jsxdata: React.PropTypes.object,
    fetchUrl: React.PropTypes.string,
    fetchParams: React.PropTypes.object,
    rowSelector: React.PropTypes.string,
    actionBar: React.PropTypes.oneOfType([React.PropTypes.array, React.PropTypes.object]),
    processData: React.PropTypes.func,
    beforeFetch: React.PropTypes.func,
    onFetchError: React.PropTypes.func,
    addRowClassName: React.PropTypes.func,
    passedData: React.PropTypes.object,
    // For inline edit
    getSavedData: React.PropTypes.bool,
    onChange: React.PropTypes.func,
    // For tree Mode
    renderModel: React.PropTypes.string,
    levels: React.PropTypes.number
};

Table.displayName = "Table";
Table.CellField = CellField;
Table.Constants = Const;

module.exports = Table;
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Tinymce Component for uxcore
 * Inspired by react-tinymce: https://github.com/mzabriskie/react-tinymce
 * @author eternalsky
 *
 * Copyright 2014-2015, Uxcore Team, Alinw.
 * All rights reserved.
 */

var React = require('react');
var ReactDOM = require('react-dom');
var util = require('./util');
var EditorConfig = require('./editorConfig');
var assign = require('object-assign');
// Include all of the Native DOM and custom events from:
// https://github.com/tinymce/tinymce/blob/master/tools/docs/tinymce.Editor.js#L5-L12
var EVENTS = ['focusin', 'focusout', 'click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'beforepaste', 'paste', 'cut', 'copy', 'selectionchange', 'mouseout', 'mouseenter', 'mouseleave', 'keydown', 'keypress', 'keyup', 'contextmenu', 'dragend', 'dragover', 'draggesture', 'dragdrop', 'drop', 'drag', 'BeforeRenderUI', 'SetAttrib', 'PreInit', 'PostRender', 'init', 'deactivate', 'activate', 'NodeChange', 'BeforeExecCommand', 'ExecCommand', 'show', 'hide', 'ProgressState', 'LoadContent', 'SaveContent', 'BeforeSetContent', 'SetContent', 'BeforeGetContent', 'GetContent', 'VisualAid', 'remove', 'submit', 'reset', 'BeforeAddUndo', 'AddUndo', 'change', 'undo', 'redo', 'ClearUndos', 'ObjectSelected', 'ObjectResizeStart', 'ObjectResized', 'PreProcess', 'PostProcess', 'focus', 'blur'];

// Note: because the capitalization of the events is weird, we're going to get
// some inconsistently-named handlers, for example compare:
// 'onMouseleave' and 'onNodeChange'
var HANDLER_NAMES = EVENTS.map(function (event) {
    return 'on' + util.uc_first(event);
});

var Tinymce = function (_React$Component) {
    _inherits(Tinymce, _React$Component);

    function Tinymce(props) {
        _classCallCheck(this, Tinymce);

        return _possibleConstructorReturn(this, _React$Component.call(this, props));
    }

    Tinymce.prototype.componentWillMount = function componentWillMount() {
        if ((typeof tinymce === 'undefined' ? 'undefined' : _typeof(tinymce)) !== 'object') {
            console.warn("TinyMCE is not found in global, init failed");
        }
        this.id = this.id || util.uuid();
    };

    Tinymce.prototype.componentDidMount = function componentDidMount() {
        this._init(this.props.config);
    };

    Tinymce.prototype.componentWillUnmount = function componentWillUnmount() {
        this._remove();
    };

    Tinymce.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (!util.isEqual(nextProps.config, this.props.config)) {
            this._init(nextProps.config, nextProps.content);
        }
    };

    Tinymce.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        return !util.isEqual(this.props.content, nextProps.content) || !util.isEqual(this.props.config, nextProps.config);
    };

    Tinymce.prototype.resetValue = function resetValue(value) {
        tinymce.get(this.id).setContent(value);
    };

    Tinymce.prototype._init = function _init(config, content) {
        var me = this;
        if (me._isInit) {
            me._remove();
        }
        // hide the textarea until init finished
        ReactDOM.findDOMNode(me).style.visibility = 'hidden';
        config.selector = '#' + me.id;
        config = assign({}, EditorConfig, config);
        if (!config.language) {
            config.language = 'zh_CN';
        }
        config.setup = function (editor) {
            EVENTS.forEach(function (event, index) {
                var handler = me.props[HANDLER_NAMES[index]];
                if (typeof handler !== 'function') return;
                editor.on(event, function (e) {
                    // native DOM events don't have access to the editor so we pass it here
                    handler(e, editor);
                });
            });
            // need to set content here because the textarea will still have the
            // old `this.props.content`
            if (content) {
                editor.on('init', function () {
                    editor.setContent(content);
                });
            }
        };
        tinymce.baseURL = '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/';
        tinymce.init(config);
        ReactDOM.findDOMNode(me).style.visibility = "";
        me._isInit = true;
    };

    Tinymce.prototype._remove = function _remove() {
        tinymce.EditorManager.execCommand("mceRemoveEditor", true, this.id);
        this._isInit = false;
    };

    Tinymce.prototype.render = function render() {
        return React.createElement('textarea', { id: this.id, defaultValue: this.props.content, placeholder: this.props.placeholder });
    };

    return Tinymce;
}(React.Component);

Tinymce.defaultProps = {
    config: {}
};

// http://facebook.github.io/react/docs/reusable-components.html
Tinymce.propTypes = {
    config: React.PropTypes.object,
    content: React.PropTypes.string
};

//add handler propTypes
HANDLER_NAMES.forEach(function (name) {
    Tinymce.propTypes[name] = React.PropTypes.func;
});

Tinymce.displayName = "Tinymce";

module.exports = Tinymce;
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Form Component for uxcore
 * @author eternalsky
 *
 * Copyright 2014-2015, Uxcore Team, Alinw.
 * All rights reserved.
 */

var React = require('react');
var ReactDOM = require('react-dom');
var FormRow = require("./FormRow");
var FormRowTitle = require("./FormRowTitle");
var FormField = require("./FormField/FormField");

var Constants = require("uxcore-const");
var Validators = require("./Validators");
var KeyCode = require('./KeyCode');

var classnames = require('classnames');
var assign = require('object-assign');
var deepcopy = require('deepcopy');
var deepEqual = require('deep-equal');

var Form = function (_React$Component) {
    _inherits(Form, _React$Component);

    function Form(props) {
        _classCallCheck(this, Form);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _this.fields = {};
        _this.errors = {};
        _this.data = {};
        _this.state = {};
        return _this;
    }

    Form.prototype.componentDidMount = function componentDidMount() {
        var me = this;
    };

    Form.prototype._copy = function _copy(a) {
        return deepcopy(a);
    };

    Form.prototype.attachFormField = function attachFormField(field) {
        var name = field.getName();
        if (!name) {
            console.warn("Each field needs a name to identify itself");
        } else {
            this.fields[name] = field;
        }
    };

    Form.prototype.detachFormField = function detachFormField(field) {
        var name = field.getName();
        delete this.fields[name];
        delete this.data[name];
    };

    Form.prototype.handleDataChange = function handleDataChange(field, fieldData, fromMount) {
        var me = this;
        me.data[field.props.jsxname] = fieldData.value;
        if (!fromMount) {
            me.props.jsxonChange(me._copy(me.data), field.props.jsxname, fieldData.pass);
        }
    };

    Form.prototype.getValues = function getValues(force) {
        var me = this;
        var _flag = me.doValidate(force);
        return {
            values: me._copy(me.data),
            pass: _flag
        };
    };

    Form.prototype.resetValues = function resetValues() {
        var me = this;
        var keys = Object.keys(me.fields);
        var data = me.props.jsxvalues || me.props.passedData || {};
        for (var i = 0; i < keys.length; i++) {
            me.fields[keys[i]].handleDataChange(data[keys[i]] == undefined ? null : data[keys[i]], true);
        }
    };

    /*
     * set Form values manually
     */

    Form.prototype.setValues = function setValues(data) {
        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) != 'object') return;
        var me = this;
        var savedData = me.data;
        var keys = Object.keys(data);
        for (var i = 0; i < keys.length; i++) {
            if (!deepEqual(data[keys[i]], savedData[keys[i]])) {
                me.fields[keys[i]].handleDataChange(data[keys[i]] == undefined ? null : data[keys[i]], true);
            }
        }
    };

    Form.prototype.doValidate = function doValidate(force) {
        var me = this;
        var pass = true;
        var keys = Object.keys(me.fields);
        for (var i = 0; i < keys.length; i++) {
            var itemPass = me.fields[keys[i]].doValidate(force);
            me.errors[keys[i]] = !itemPass;
            if (!itemPass) {
                pass = false;
            }
        }
        return pass;
    };

    Form.prototype.isDirty = function isDirty() {
        return !this.doValidate();
    };

    /*
     * 统一数据流，所有的 props，通过 Form -> FormRow -> FormField 向下传递，如果有的
     * 子元素是 FormField，则自动在他的外面包一层 FormRow。
     * @param {React Elements Array} children this.props.children
     */

    Form.prototype._processChild = function _processChild(children) {
        var length = React.Children.count(children);
        var elements = [];
        if (length == 0) {
            console.warn("FORM: You must pass children to the form component");
            return false;
        }

        React.Children.forEach(children, function (child, index) {
            // 如果是自己添加的 DOM 直接抛弃
            if (typeof child.type == 'function') {
                var displayName = child.type.displayName;
                if (displayName === 'EngineNode') {
                    displayName = child.props._componentName;
                }
                if (/FormField/.test(displayName)) {
                    elements.push(React.createElement(
                        FormRow,
                        null,
                        child
                    ));
                } else if (/FormRow/.test(displayName)) {
                    elements.push(child);
                }
            }
        });

        return elements;
    };

    Form.prototype.render = function render() {
        var _classnames;

        var me = this;
        var elements = me._processChild(me.props.children);

        return React.createElement(
            'div',
            { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames["kuma-uxform-edit-mode"] = me.props.jsxmode == Constants.MODE.EDIT, _classnames["kuma-uxform-view-mode"] = me.props.jsxmode == Constants.MODE.VIEW, _classnames)) },
            !!elements && elements.map(function (child, index) {
                return React.cloneElement(child, {
                    mode: me.props.jsxmode,
                    instantValidate: me.props.instantValidate,
                    data: deepcopy(me.props.jsxvalues || me.props.passedData || {}),
                    key: index,
                    attachFormField: me.attachFormField.bind(me),
                    detachFormField: me.detachFormField.bind(me),
                    handleDataChange: me.handleDataChange.bind(me),
                    getValues: me.getValues.bind(me),
                    resetValues: me.resetValues.bind(me)
                });
            })
        );
    };

    return Form;
}(React.Component);

// 以 Form 的插件的形式给出


Form.FormRow = FormRow;
Form.FormRowTitle = FormRowTitle;
Form.FormField = FormField;

// Form.MentionFormField = MentionFormField;
Form.Constants = Constants;
Form.Validators = Validators;
Form.KeyCode = KeyCode;

Form.defaultProps = {
    jsxprefixCls: "kuma-uxform",
    jsxmode: Constants.MODE.EDIT,
    instantValidate: true,
    jsxonChange: function jsxonChange() {}
};

// http://facebook.github.io/react/docs/reusable-components.html
Form.propTypes = {
    jsxprefixCls: React.PropTypes.string,
    jsxmode: React.PropTypes.string,
    jsxvalues: React.PropTypes.object,
    instantValidate: React.PropTypes.bool,
    jsxonChange: React.PropTypes.func
};

Form.displayName = "Form";

module.exports = Form;